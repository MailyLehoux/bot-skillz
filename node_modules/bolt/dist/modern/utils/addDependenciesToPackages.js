'use strict';

exports.__esModule = true;

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _Project = require('../Project');

var _Project2 = _interopRequireDefault(_Project);

var _Package = require('../Package');

var _Package2 = _interopRequireDefault(_Package);

var _messages = require('./messages');

var messages = _interopRequireWildcard(_messages);

var _errors = require('./errors');

var _logger = require('./logger');

var logger = _interopRequireWildcard(_logger);

var _yarn = require('./yarn');

var yarn = _interopRequireWildcard(_yarn);

var _symlinkPackageDependencies = require('./symlinkPackageDependencies');

var _symlinkPackageDependencies2 = _interopRequireDefault(_symlinkPackageDependencies);

var _updateWorkspaceDependencies = require('../functions/updateWorkspaceDependencies');

var _updateWorkspaceDependencies2 = _interopRequireDefault(_updateWorkspaceDependencies);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = async function addDependenciesToPackage(project, pkg, dependencies, type = 'dependencies') {
  let packages = await project.getPackages();
  let projectDependencies = project.pkg.getAllDependencies();
  let pkgDependencies = pkg.getAllDependencies();
  let { graph: depGraph } = await project.getDependencyGraph(packages);
  let inProjectRoot = pkg.isSamePackage(project.pkg);

  let dependencyNames = dependencies.map(dep => dep.name);
  let externalDeps = dependencies.filter(dep => !depGraph.has(dep.name));
  let internalDeps = dependencies.filter(dep => depGraph.has(dep.name));

  let externalDepsToInstallForProject = externalDeps.filter(
  // If we are in the project, always (re)install external deps to keep same behaviour as yarn
  // Otherwise, if in a workspace, only project install if it isn't already installed
  dep => inProjectRoot || !projectDependencies.has(dep.name));
  if (externalDepsToInstallForProject.length !== 0) {
    await yarn.add(project.pkg, externalDepsToInstallForProject, type);
    // we reinitialise the project config because it will be modified externally by yarn
    project = await _Project2.default.init(project.pkg.dir);
  }
  if (inProjectRoot) {
    if (internalDeps.length > 0) {
      throw new _errors.BoltError(messages.cannotInstallWorkspaceInProject(internalDeps[0].name));
    }

    // Update all workspace versions
    const depsToUpgrade = externalDeps.reduce((prev, dep) => {
      prev[dep.name] = project.pkg.getDependencyVersionRange(dep.name);
      return prev;
    }, {});
    await (0, _updateWorkspaceDependencies2.default)(depsToUpgrade, {
      cwd: project.pkg.dir
    });
    return true;
  }

  let installedVersions = {};

  for (let dep of externalDeps) {
    let installed = project.pkg.getDependencyVersionRange(dep.name);
    // If we aren't specified a version, use the same one from the project
    let depVersion = dep.version || installed;
    if (depVersion !== installed) {
      throw new _errors.BoltError(messages.depMustMatchProject(pkg.config.getName(), dep.name, installed, depVersion));
    }
    installedVersions[dep.name] = depVersion;
  }

  for (let dep of internalDeps) {
    let dependencyPkg = (depGraph.get(dep.name) || {}).pkg;
    let internalVersion = dependencyPkg.config.getVersion();
    // If no version is requested, default to caret at the current version
    let requestedVersion = dep.version || `^${internalVersion}`;
    if (!_semver2.default.satisfies(internalVersion, requestedVersion)) {
      throw new _errors.BoltError(messages.packageMustDependOnCurrentVersion(pkg.config.getName(), dep.name, internalVersion, requestedVersion));
    }
    installedVersions[dep.name] = requestedVersion;
  }

  for (let [depName, depVersion] of (0, _entries2.default)(installedVersions)) {
    await pkg.setDependencyVersionRange(depName, type, String(depVersion));
  }

  // Now that all the new stuff is there, do this one more time to get the updates
  let packagesFinal = await project.getPackages();
  let { graph: depGraphFinal } = await project.getDependencyGraph(packagesFinal);

  await (0, _symlinkPackageDependencies2.default)(project, pkg, dependencyNames, depGraphFinal);
};