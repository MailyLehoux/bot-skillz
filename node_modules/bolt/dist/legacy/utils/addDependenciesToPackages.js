'use strict';

exports.__esModule = true;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _Project = require('../Project');

var _Project2 = _interopRequireDefault(_Project);

var _Package = require('../Package');

var _Package2 = _interopRequireDefault(_Package);

var _messages = require('./messages');

var messages = _interopRequireWildcard(_messages);

var _errors = require('./errors');

var _logger = require('./logger');

var logger = _interopRequireWildcard(_logger);

var _yarn = require('./yarn');

var yarn = _interopRequireWildcard(_yarn);

var _symlinkPackageDependencies = require('./symlinkPackageDependencies');

var _symlinkPackageDependencies2 = _interopRequireDefault(_symlinkPackageDependencies);

var _updateWorkspaceDependencies = require('../functions/updateWorkspaceDependencies');

var _updateWorkspaceDependencies2 = _interopRequireDefault(_updateWorkspaceDependencies);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(project, pkg, dependencies) {
    var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'dependencies';

    var packages, projectDependencies, pkgDependencies, _ref2, depGraph, inProjectRoot, dependencyNames, externalDeps, internalDeps, externalDepsToInstallForProject, depsToUpgrade, installedVersions, _iterator, _isArray, _i, _ref3, dep, installed, depVersion, _iterator2, _isArray2, _i2, _ref4, _dep, dependencyPkg, internalVersion, requestedVersion, _iterator3, _isArray3, _i3, _ref6, _ref5, depName, packagesFinal, _ref7, depGraphFinal;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return project.getPackages();

          case 2:
            packages = _context.sent;
            projectDependencies = project.pkg.getAllDependencies();
            pkgDependencies = pkg.getAllDependencies();
            _context.next = 7;
            return project.getDependencyGraph(packages);

          case 7:
            _ref2 = _context.sent;
            depGraph = _ref2.graph;
            inProjectRoot = pkg.isSamePackage(project.pkg);
            dependencyNames = dependencies.map(function (dep) {
              return dep.name;
            });
            externalDeps = dependencies.filter(function (dep) {
              return !depGraph.has(dep.name);
            });
            internalDeps = dependencies.filter(function (dep) {
              return depGraph.has(dep.name);
            });
            externalDepsToInstallForProject = externalDeps.filter(
            // If we are in the project, always (re)install external deps to keep same behaviour as yarn
            // Otherwise, if in a workspace, only project install if it isn't already installed
            function (dep) {
              return inProjectRoot || !projectDependencies.has(dep.name);
            });

            if (!(externalDepsToInstallForProject.length !== 0)) {
              _context.next = 20;
              break;
            }

            _context.next = 17;
            return yarn.add(project.pkg, externalDepsToInstallForProject, type);

          case 17:
            _context.next = 19;
            return _Project2.default.init(project.pkg.dir);

          case 19:
            project = _context.sent;

          case 20:
            if (!inProjectRoot) {
              _context.next = 27;
              break;
            }

            if (!(internalDeps.length > 0)) {
              _context.next = 23;
              break;
            }

            throw new _errors.BoltError(messages.cannotInstallWorkspaceInProject(internalDeps[0].name));

          case 23:

            // Update all workspace versions
            depsToUpgrade = externalDeps.reduce(function (prev, dep) {
              prev[dep.name] = project.pkg.getDependencyVersionRange(dep.name);
              return prev;
            }, {});
            _context.next = 26;
            return (0, _updateWorkspaceDependencies2.default)(depsToUpgrade, {
              cwd: project.pkg.dir
            });

          case 26:
            return _context.abrupt('return', true);

          case 27:
            installedVersions = {};
            _iterator = externalDeps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);

          case 29:
            if (!_isArray) {
              _context.next = 35;
              break;
            }

            if (!(_i >= _iterator.length)) {
              _context.next = 32;
              break;
            }

            return _context.abrupt('break', 47);

          case 32:
            _ref3 = _iterator[_i++];
            _context.next = 39;
            break;

          case 35:
            _i = _iterator.next();

            if (!_i.done) {
              _context.next = 38;
              break;
            }

            return _context.abrupt('break', 47);

          case 38:
            _ref3 = _i.value;

          case 39:
            dep = _ref3;
            installed = project.pkg.getDependencyVersionRange(dep.name);
            // If we aren't specified a version, use the same one from the project

            depVersion = dep.version || installed;

            if (!(depVersion !== installed)) {
              _context.next = 44;
              break;
            }

            throw new _errors.BoltError(messages.depMustMatchProject(pkg.config.getName(), dep.name, installed, depVersion));

          case 44:
            installedVersions[dep.name] = depVersion;

          case 45:
            _context.next = 29;
            break;

          case 47:
            _iterator2 = internalDeps, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);

          case 48:
            if (!_isArray2) {
              _context.next = 54;
              break;
            }

            if (!(_i2 >= _iterator2.length)) {
              _context.next = 51;
              break;
            }

            return _context.abrupt('break', 67);

          case 51:
            _ref4 = _iterator2[_i2++];
            _context.next = 58;
            break;

          case 54:
            _i2 = _iterator2.next();

            if (!_i2.done) {
              _context.next = 57;
              break;
            }

            return _context.abrupt('break', 67);

          case 57:
            _ref4 = _i2.value;

          case 58:
            _dep = _ref4;
            dependencyPkg = (depGraph.get(_dep.name) || {}).pkg;
            internalVersion = dependencyPkg.config.getVersion();
            // If no version is requested, default to caret at the current version

            requestedVersion = _dep.version || `^${internalVersion}`;

            if (_semver2.default.satisfies(internalVersion, requestedVersion)) {
              _context.next = 64;
              break;
            }

            throw new _errors.BoltError(messages.packageMustDependOnCurrentVersion(pkg.config.getName(), _dep.name, internalVersion, requestedVersion));

          case 64:
            installedVersions[_dep.name] = requestedVersion;

          case 65:
            _context.next = 48;
            break;

          case 67:
            _iterator3 = (0, _entries2.default)(installedVersions), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);

          case 68:
            if (!_isArray3) {
              _context.next = 74;
              break;
            }

            if (!(_i3 >= _iterator3.length)) {
              _context.next = 71;
              break;
            }

            return _context.abrupt('break', 85);

          case 71:
            _ref6 = _iterator3[_i3++];
            _context.next = 78;
            break;

          case 74:
            _i3 = _iterator3.next();

            if (!_i3.done) {
              _context.next = 77;
              break;
            }

            return _context.abrupt('break', 85);

          case 77:
            _ref6 = _i3.value;

          case 78:
            _ref5 = _ref6;
            depName = _ref5[0];
            depVersion = _ref5[1];
            _context.next = 83;
            return pkg.setDependencyVersionRange(depName, type, String(depVersion));

          case 83:
            _context.next = 68;
            break;

          case 85:
            _context.next = 87;
            return project.getPackages();

          case 87:
            packagesFinal = _context.sent;
            _context.next = 90;
            return project.getDependencyGraph(packagesFinal);

          case 90:
            _ref7 = _context.sent;
            depGraphFinal = _ref7.graph;
            _context.next = 94;
            return (0, _symlinkPackageDependencies2.default)(project, pkg, dependencyNames, depGraphFinal);

          case 94:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  function addDependenciesToPackage(_x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  }

  return addDependenciesToPackage;
}();